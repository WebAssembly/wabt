%%includes
/* Automically generated by wasm2c */
#include <math.h>
#include <string.h>
#include <stdlib.h>
%%declarations
#if defined(_MSC_VER)
#  define UNLIKELY(x) (x)
#  define LIKELY(x) (x)
#else
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#endif

#define TRAP(x) (wasm_rt_trap(WASM_RT_TRAP_##x), 0)

#ifndef FUNC_PROLOGUE
#define FUNC_PROLOGUE
#endif

#ifndef FUNC_EPILOGUE
#define FUNC_EPILOGUE
#endif

#ifdef EXTERNAL_CALLBACK_PROLOGUE
#define EXTERNAL_CALLBACK_PROLOGUE_EXEC(table, x)                        \
  if (UNLIKELY(table.data[x].func_class == WASM_RT_EXTERNAL_FUNCTION)) { \
    EXTERNAL_CALLBACK_PROLOGUE;                                          \
  }
#else
#define EXTERNAL_CALLBACK_PROLOGUE_EXEC(table, x)
#endif

#ifdef EXTERNAL_CALLBACK_EPILOGUE
#define EXTERNAL_CALLBACK_EPILOGUE_EXEC(table, x)                        \
  if (UNLIKELY(table.data[x].func_class == WASM_RT_EXTERNAL_FUNCTION)) { \
    EXTERNAL_CALLBACK_EPILOGUE;                                          \
  }
#else
#define EXTERNAL_CALLBACK_EPILOGUE_EXEC(table, x)
#endif

#define UNREACHABLE (void) TRAP(UNREACHABLE)

#define CALL_INDIRECT_VOID(table, t, ft, x, func_types, ...)                                         \
  if (LIKELY((x) < table.size && table.data[x].func && table.data[x].func_type == func_types[ft])) { \
    EXTERNAL_CALLBACK_PROLOGUE_EXEC(table, x);                                                       \
    ((t)table.data[x].func)(__VA_ARGS__);                                                            \
    EXTERNAL_CALLBACK_EPILOGUE_EXEC(table, x);                                                       \
  } else {                                                                                           \
    wasm_rt_callback_error_trap(&table, x, func_types[ft]);                                          \
  }

#define CALL_INDIRECT_RES(res, table, t, ft, x, func_types, ...)                                     \
  if (LIKELY((x) < table.size && table.data[x].func && table.data[x].func_type == func_types[ft])) { \
    EXTERNAL_CALLBACK_PROLOGUE_EXEC(table, x);                                                       \
    res = ((t)table.data[x].func)(__VA_ARGS__);                                                      \
    EXTERNAL_CALLBACK_EPILOGUE_EXEC(table, x);                                                       \
  } else {                                                                                           \
    wasm_rt_callback_error_trap(&table, x, func_types[ft]);                                          \
  }

#if defined(WASM_CHECK_SHADOW_MEMORY)
#  define WASM2C_SHADOW_MEMORY_LOAD(mem, func_name, ptr, ptr_size)  wasm2c_shadow_memory_load(mem, func_name, ptr, ptr_size)
#  define WASM2C_SHADOW_MEMORY_STORE(mem, func_name, ptr, ptr_size) wasm2c_shadow_memory_store(mem, func_name, ptr, ptr_size)
#  define WASM2C_SHADOW_MEMORY_RESERVE(mem, ptr, ptr_size)          wasm2c_shadow_memory_reserve(mem, ptr, ptr_size)
#  define WASM2C_SHADOW_MEMORY_DLMALLOC(mem, ptr, ptr_size)         wasm2c_shadow_memory_dlmalloc(mem, ptr, ptr_size)
#  define WASM2C_SHADOW_MEMORY_DLFREE(mem, ptr)                     wasm2c_shadow_memory_dlfree(mem, ptr)
#  define WASM2C_SHADOW_MEMORY_MARK_GLOBALS_HEAP_BOUNDARY(mem, ptr) wasm2c_shadow_memory_mark_globals_heap_boundary(mem, ptr)
#else
#  define WASM2C_SHADOW_MEMORY_LOAD(mem, func_name, ptr, ptr_size)
#  define WASM2C_SHADOW_MEMORY_STORE(mem, func_name, ptr, ptr_size)
#  define WASM2C_SHADOW_MEMORY_RESERVE(mem, ptr, ptr_size)
#  define WASM2C_SHADOW_MEMORY_DLMALLOC(mem, ptr, ptr_size)
#  define WASM2C_SHADOW_MEMORY_DLFREE(mem, ptr)
#  define WASM2C_SHADOW_MEMORY_MARK_GLOBALS_HEAP_BOUNDARY(mem, ptr)
#endif

#ifdef WASM_USE_GUARD_PAGES
#  define MEMCHECK(mem, a, t)
#else
#  define MEMCHECK(mem, a, t) if (UNLIKELY((a) + sizeof(t) > mem->size)) { (void) TRAP(OOB); }
#endif

#if defined(WASM_USE_GUARD_PAGES) && UINTPTR_MAX == 0xffffffff
// on 32-bit platforms we have to mask memory access into range
#  define MEM_ACCESS_REF(mem, addr) &mem->data[addr & 0x7fffff]
#else
#  define MEM_ACCESS_REF(mem, addr) &mem->data[addr]
#endif

#if defined(WASM_USING_GLOBAL_HEAP)
#  undef MEM_ACCESS_REF
#  define MEM_ACCESS_REF(mem, addr) (char*) addr
#endif

#if WABT_BIG_ENDIAN
static inline void load_data(void *dest, const void *src, size_t n) {
  size_t i = 0;
  u8 *dest_chars = dest;
  memcpy(dest, src, n);
  for (i = 0; i < (n>>1); i++) {
    u8 cursor = dest_chars[i];
    dest_chars[i] = dest_chars[n - i - 1];
    dest_chars[n - i - 1] = cursor;
  }
}
#define LOAD_DATA(m, o, i, s) { load_data(&(m.data[m.size - o - s]), i, s); \
  WASM2C_SHADOW_MEMORY_RESERVE(&m, m.size - o - s, s);                       \
  WASM2C_SHADOW_MEMORY_STORE(&m, "GlobalDataLoad", m.size - o - s, s);       \
}

#define DEFINE_LOAD(name, t1, t2, t3)                                                      \
  static inline t3 name(wasm_rt_memory_t* mem, u64 addr, const char* func_name) {          \
    MEMCHECK(mem, addr, t1);                                                               \
    t1 result;                                                                             \
    memcpy(&result, MEM_ACCESS_REF(mem, mem->size - addr - sizeof(t1)), sizeof(t1));       \
    WASM2C_SHADOW_MEMORY_LOAD(mem, func_name, mem->size - addr - sizeof(t1), sizeof(t1));  \
    return (t3)(t2)result;                                                                 \
  }

#define DEFINE_STORE(name, t1, t2)                                                            \
  static inline void name(wasm_rt_memory_t* mem, u64 addr, t2 value, const char* func_name) { \
    MEMCHECK(mem, addr, t1);                                                                  \
    t1 wrapped = (t1)value;                                                                   \
    memcpy(MEM_ACCESS_REF(mem, mem->size - addr - sizeof(t1), &wrapped, sizeof(t1));          \
    WASM2C_SHADOW_MEMORY_STORE(mem, func_name, mem->size - addr - sizeof(t1)), sizeof(t1));   \
  }
#else
static inline void load_data(void *dest, const void *src, size_t n) {
  memcpy(dest, src, n);
}
#define LOAD_DATA(m, o, i, s) { load_data(&(m.data[o]), i, s); \
  WASM2C_SHADOW_MEMORY_RESERVE(&m, o, s);                       \
  WASM2C_SHADOW_MEMORY_STORE(&m, "GlobalDataLoad", o, s);       \
}

#define DEFINE_LOAD(name, t1, t2, t3)                                               \
  static inline t3 name(wasm_rt_memory_t* mem, u64 addr, const char* func_name) {   \
    MEMCHECK(mem, addr, t1);                                                        \
    t1 result;                                                                      \
    memcpy(&result, MEM_ACCESS_REF(mem, addr), sizeof(t1));                         \
    WASM2C_SHADOW_MEMORY_LOAD(mem, func_name, addr, sizeof(t1));                    \
    return (t3)(t2)result;                                                          \
  }

#define DEFINE_STORE(name, t1, t2)                                                            \
  static inline void name(wasm_rt_memory_t* mem, u64 addr, t2 value, const char* func_name) { \
    MEMCHECK(mem, addr, t1);                                                                  \
    t1 wrapped = (t1)value;                                                                   \
    memcpy(MEM_ACCESS_REF(mem, addr), &wrapped, sizeof(t1));                                  \
    WASM2C_SHADOW_MEMORY_STORE(mem, func_name, addr, sizeof(t1));                             \
  }
#endif

DEFINE_LOAD(i32_load, u32, u32, u32);
DEFINE_LOAD(i64_load, u64, u64, u64);
DEFINE_LOAD(f32_load, f32, f32, f32);
DEFINE_LOAD(f64_load, f64, f64, f64);
DEFINE_LOAD(i32_load8_s, s8, s32, u32);
DEFINE_LOAD(i64_load8_s, s8, s64, u64);
DEFINE_LOAD(i32_load8_u, u8, u32, u32);
DEFINE_LOAD(i64_load8_u, u8, u64, u64);
DEFINE_LOAD(i32_load16_s, s16, s32, u32);
DEFINE_LOAD(i64_load16_s, s16, s64, u64);
DEFINE_LOAD(i32_load16_u, u16, u32, u32);
DEFINE_LOAD(i64_load16_u, u16, u64, u64);
DEFINE_LOAD(i64_load32_s, s32, s64, u64);
DEFINE_LOAD(i64_load32_u, u32, u64, u64);
DEFINE_STORE(i32_store, u32, u32);
DEFINE_STORE(i64_store, u64, u64);
DEFINE_STORE(f32_store, f32, f32);
DEFINE_STORE(f64_store, f64, f64);
DEFINE_STORE(i32_store8, u8, u32);
DEFINE_STORE(i32_store16, u16, u32);
DEFINE_STORE(i64_store8, u8, u64);
DEFINE_STORE(i64_store16, u16, u64);
DEFINE_STORE(i64_store32, u32, u64);

#if defined(_MSC_VER)
#include <intrin.h>

// Adapted from https://github.com/nemequ/portable-snippets/blob/master/builtin/builtin.h

static inline int I64_CLZ(unsigned long long v) {
  unsigned long r = 0;
#if defined(_M_AMD64) || defined(_M_ARM)
    if (_BitScanReverse64(&r, v)) {
      return 63 - r;
    }
#else
    if (_BitScanReverse(&r, (unsigned long) (v >> 32))) {
      return 31 - r;
    } else if (_BitScanReverse(&r, (unsigned long) v)) {
      return 63 - r;
    }
#endif
  return 64;
}

static inline int I32_CLZ(unsigned long v) {
  unsigned long r = 0;
  if (_BitScanReverse(&r, v)) {
    return 31 - r;
  }
  return 32;
}

static inline int I64_CTZ(unsigned long long v) {
  if (!v) {
    return 64;
  }
  unsigned long r = 0;
#if defined(_M_AMD64) || defined(_M_ARM)
    _BitScanForward64(&r, v);
    return (int) r;
#else
    if (_BitScanForward(&r, (unsigned int) (v))) {
      return (int) (r);
    }

    _BitScanForward(&r, (unsigned int) (v >> 32));
    return (int) (r + 32);
#endif
}

static inline int I32_CTZ(unsigned long v) {
  if (!v) {
    return 32;
  }
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return (int) r;
}

#define POPCOUNT_DEFINE_PORTABLE(f_n, T)                    \
  static inline u32 f_n(T x) {                              \
    x = x - ((x >> 1) & (T)~(T)0/3);                        \
    x = (x & (T)~(T)0/15*3) + ((x >> 2) & (T)~(T)0/15*3);   \
    x = (x + (x >> 4)) & (T)~(T)0/255*15;                   \
    return (T)(x * ((T)~(T)0/255)) >> (sizeof(T) - 1) * 8;  \
  }

POPCOUNT_DEFINE_PORTABLE(I32_POPCNT, u32)
POPCOUNT_DEFINE_PORTABLE(I64_POPCNT, u64)

#undef POPCOUNT_DEFINE_PORTABLE

#else
#  define I32_CLZ(x) ((x) ? __builtin_clz(x) : 32)
#  define I64_CLZ(x) ((x) ? __builtin_clzll(x) : 64)
#  define I32_CTZ(x) ((x) ? __builtin_ctz(x) : 32)
#  define I64_CTZ(x) ((x) ? __builtin_ctzll(x) : 64)
#  define I32_POPCNT(x) (__builtin_popcount(x))
#  define I64_POPCNT(x) (__builtin_popcountll(x))
#endif

#define DIV_S(ut, min, x, y)                                 \
   ((UNLIKELY((y) == 0)) ?                TRAP(DIV_BY_ZERO)  \
  : (UNLIKELY((x) == min && (y) == -1)) ? TRAP(INT_OVERFLOW) \
  : (ut)((x) / (y)))

#define REM_S(ut, min, x, y)                                \
   ((UNLIKELY((y) == 0)) ?                TRAP(DIV_BY_ZERO) \
  : (UNLIKELY((x) == min && (y) == -1)) ? 0                 \
  : (ut)((x) % (y)))

#define I32_DIV_S(x, y) DIV_S(u32, INT32_MIN, (s32)x, (s32)y)
#define I64_DIV_S(x, y) DIV_S(u64, INT64_MIN, (s64)x, (s64)y)
#define I32_REM_S(x, y) REM_S(u32, INT32_MIN, (s32)x, (s32)y)
#define I64_REM_S(x, y) REM_S(u64, INT64_MIN, (s64)x, (s64)y)

#define DIVREM_U(op, x, y) \
  ((UNLIKELY((y) == 0)) ? TRAP(DIV_BY_ZERO) : ((x) op (y)))

#define DIV_U(x, y) DIVREM_U(/, x, y)
#define REM_U(x, y) DIVREM_U(%, x, y)

#define ROTL(x, y, mask) \
  (((x) << ((y) & (mask))) | ((x) >> (((mask) - (y) + 1) & (mask))))
#define ROTR(x, y, mask) \
  (((x) >> ((y) & (mask))) | ((x) << (((mask) - (y) + 1) & (mask))))

#define I32_ROTL(x, y) ROTL(x, y, 31)
#define I64_ROTL(x, y) ROTL(x, y, 63)
#define I32_ROTR(x, y) ROTR(x, y, 31)
#define I64_ROTR(x, y) ROTR(x, y, 63)

#define FMIN(x, y)                                          \
   ((UNLIKELY((x) != (x))) ? NAN                            \
  : (UNLIKELY((y) != (y))) ? NAN                            \
  : (UNLIKELY((x) == 0 && (y) == 0)) ? (signbit(x) ? x : y) \
  : (x < y) ? x : y)

#define FMAX(x, y)                                          \
   ((UNLIKELY((x) != (x))) ? NAN                            \
  : (UNLIKELY((y) != (y))) ? NAN                            \
  : (UNLIKELY((x) == 0 && (y) == 0)) ? (signbit(x) ? y : x) \
  : (x > y) ? x : y)

#define TRUNC_S(ut, st, ft, min, minop, max, x)                             \
  ((UNLIKELY((x) != (x)))                        ? TRAP(INVALID_CONVERSION) \
   : (UNLIKELY(!((x)minop(min) && (x) < (max)))) ? TRAP(INT_OVERFLOW)       \
                                                 : (ut)(st)(x))

#define I32_TRUNC_S_F32(x) TRUNC_S(u32, s32, f32, (f32)INT32_MIN, >=, 2147483648.f, x)
#define I64_TRUNC_S_F32(x) TRUNC_S(u64, s64, f32, (f32)INT64_MIN, >=, (f32)INT64_MAX, x)
#define I32_TRUNC_S_F64(x) TRUNC_S(u32, s32, f64, -2147483649., >, 2147483648., x)
#define I64_TRUNC_S_F64(x) TRUNC_S(u64, s64, f64, (f64)INT64_MIN, >=, (f64)INT64_MAX, x)

#define TRUNC_U(ut, ft, max, x)                                            \
  ((UNLIKELY((x) != (x)))                       ? TRAP(INVALID_CONVERSION) \
   : (UNLIKELY(!((x) > (ft)-1 && (x) < (max)))) ? TRAP(INT_OVERFLOW)       \
                                                : (ut)(x))

#define I32_TRUNC_U_F32(x) TRUNC_U(u32, f32, 4294967296.f, x)
#define I64_TRUNC_U_F32(x) TRUNC_U(u64, f32, (f32)UINT64_MAX, x)
#define I32_TRUNC_U_F64(x) TRUNC_U(u32, f64, 4294967296.,  x)
#define I64_TRUNC_U_F64(x) TRUNC_U(u64, f64, (f64)UINT64_MAX, x)

#define TRUNC_SAT_S(ut, st, ft, min, smin, minop, max, smax, x) \
  ((UNLIKELY((x) != (x)))         ? 0                           \
   : (UNLIKELY(!((x)minop(min)))) ? smin                        \
   : (UNLIKELY(!((x) < (max))))   ? smax                        \
                                  : (ut)(st)(x))

#define I32_TRUNC_SAT_S_F32(x) TRUNC_SAT_S(u32, s32, f32, (f32)INT32_MIN, INT32_MIN, >=, 2147483648.f, INT32_MAX, x)
#define I64_TRUNC_SAT_S_F32(x) TRUNC_SAT_S(u64, s64, f32, (f32)INT64_MIN, INT64_MIN, >=, (f32)INT64_MAX, INT64_MAX, x)
#define I32_TRUNC_SAT_S_F64(x) TRUNC_SAT_S(u32, s32, f64, -2147483649., INT32_MIN, >, 2147483648., INT32_MAX, x)
#define I64_TRUNC_SAT_S_F64(x) TRUNC_SAT_S(u64, s64, f64, (f64)INT64_MIN, INT64_MIN, >=, (f64)INT64_MAX, INT64_MAX, x)

#define TRUNC_SAT_U(ut, ft, max, smax, x) \
  ((UNLIKELY((x) != (x)))        ? 0      \
   : (UNLIKELY(!((x) > (ft)-1))) ? 0      \
   : (UNLIKELY(!((x) < (max))))  ? smax   \
                                 : (ut)(x))

#define I32_TRUNC_SAT_U_F32(x) TRUNC_SAT_U(u32, f32, 4294967296.f, UINT32_MAX, x)
#define I64_TRUNC_SAT_U_F32(x) TRUNC_SAT_U(u64, f32, (f32)UINT64_MAX, UINT64_MAX, x)
#define I32_TRUNC_SAT_U_F64(x) TRUNC_SAT_U(u32, f64, 4294967296., UINT32_MAX,  x)
#define I64_TRUNC_SAT_U_F64(x) TRUNC_SAT_U(u64, f64, (f64)UINT64_MAX, UINT64_MAX, x)

#define DEFINE_REINTERPRET(name, t1, t2)  \
  static inline t2 name(t1 x) {           \
    t2 result;                            \
    memcpy(&result, &x, sizeof(result));  \
    return result;                        \
  }

DEFINE_REINTERPRET(f32_reinterpret_i32, u32, f32)
DEFINE_REINTERPRET(i32_reinterpret_f32, f32, u32)
DEFINE_REINTERPRET(f64_reinterpret_i64, u64, f64)
DEFINE_REINTERPRET(i64_reinterpret_f64, f64, u64)
%%sandboxapis
//test

static u32 add_wasm2c_callback(void* sbx_ptr, u32 func_type_idx, void* func_ptr, wasm_rt_elem_target_class_t func_class) {
  wasm_rt_table_t* table = get_wasm2c_callback_table(sbx_ptr);
  for (u32 i = 1; i < table->max_size; i++) {
    if (i >= table->size) {
      wasm_rt_expand_table(table);
    }
    if (table->data[i].func == 0) {
      table->data[i] = (wasm_rt_elem_t){ func_class, func_type_idx, (wasm_rt_anyfunc_t) func_ptr };
      return i;
    }
  }
  (void) TRAP(CALL_INDIRECT_TABLE_EXPANSION);
}

static void remove_wasm2c_callback(void* sbx_ptr, u32 callback_idx) {
  wasm_rt_table_t* table = get_wasm2c_callback_table(sbx_ptr);
  table->data[callback_idx].func = 0;
}

static u32 lookup_wasm2c_func_index(void* sbx_ptr, u32 param_count, u32 result_count, wasm_rt_type_t* types) {
  wasm2c_sandbox_t* const sbx = (wasm2c_sandbox_t* const) sbx_ptr;
  return wasm_rt_register_func_type(&sbx->func_type_structs, &sbx->func_type_count, param_count, result_count, types);
}

static void* create_wasm2c_sandbox(void) {
  wasm2c_sandbox_t* const sbx = (wasm2c_sandbox_t* const) calloc(sizeof(wasm2c_sandbox_t), 1);
  if (!init_memory(sbx)) {
    free(sbx);
    return 0;
  }
  init_func_types(sbx);
  init_globals(sbx);
  init_table(sbx);
  wasm_rt_init_wasi(&(sbx->wasi_data));
  init_module_starts();
  return sbx;
}

static void destroy_wasm2c_sandbox(void* aSbx) {
  wasm2c_sandbox_t* const sbx = (wasm2c_sandbox_t* const) aSbx;
  cleanup_memory(sbx);
  cleanup_func_types(sbx);
  cleanup_table(sbx);
  wasm_rt_cleanup_wasi(&(sbx->wasi_data));
  free(sbx);
}

FUNC_EXPORT wasm2c_sandbox_funcs_t WASM_CURR_ADD_PREFIX(get_wasm2c_sandbox_info)() {
  wasm2c_sandbox_funcs_t ret;
  ret.wasm_rt_sys_init = &wasm_rt_sys_init;
  ret.create_wasm2c_sandbox = &create_wasm2c_sandbox;
  ret.destroy_wasm2c_sandbox = &destroy_wasm2c_sandbox;
  ret.lookup_wasm2c_nonfunc_export = &lookup_wasm2c_nonfunc_export;
  ret.lookup_wasm2c_func_index = &lookup_wasm2c_func_index;
  ret.add_wasm2c_callback = &add_wasm2c_callback;
  ret.remove_wasm2c_callback = &remove_wasm2c_callback;
  return ret;
}
